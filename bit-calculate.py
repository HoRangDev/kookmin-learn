#-*- coding: utf-8 -*-
# 비트 논리 연산자에 대한 간단한 정리
# 뭔가 많아 보이지만 차근차근 읽어보세요! :)

# 1. 먼저 a와 b를 60과 13으로 놓아보자
a = 60
b = 13

# 2. a와 b는 아래와 같이 2진수(bit)로 표현이 가능하다
# 비트는 0과 1로 표현가능한것을 의미한다
# a = 0011 1100
# b = 0000 1101

# 위의 비트를 비교하는 연산자를 이용해서 계산을 할 수 있다


# & 연산자 : AND 연산. 둘다 참일때만 만족
# a 와 b의 맨첫번째를 보면 0과 0이 있다. 둘다 거짓(0)임으로 0이 나온다
# 즉 아래와 같이 계산이 가능하다
# a = 0011 1100
# b = 0000 1101
#     0000 1100 (&연산자 결과)
print("10 진법: ", (a & b), "\t|", "2 진법: ", bin(a & b) )


# | 연산자 : OR 연산. 둘 중 하나만 참이여도 만족
# a = 0011 1100
# b = 0000 1101
#     0011 1101 (| 연산자 결과)
print("10 진법: ", (a | b), "\t|", "2 진법: ", bin(a | b) )


# ^ 연산자 : XOR 연산. 둘 중 하나만 참일 때 만족 (but! 1 과 1은 0으로 처리)
# a = 0011 1100
# b = 0000 1101
#     0011 0001 (^ 연산자 결과)
print("10 진법: ", (a ^ b), "\t|", "2 진법: ", bin(a ^ b) )


# ~ 연산자 : 보수 연산(NOT 연산).
# a = 0011 1100
#     1100 0011 (~ 보수 결과)
print("10 진법: ", (~a), "\t|", "2 진법: ", bin(~a & 0xff) )


# << n 연산자 : 시프트 연산. M << n 일 때 결과값은 M x 2^n
# a = 0011 1100
#     1111 0000 (a << 1 연산 결과)
print("10 진법: ", (a << 1), "\t|", "2 진법: ", bin(a << 1) )


# >> n 연산자 : 시프트 연산자. M >> n 일 때 결과값은 M x (1/2)^n
# a = 0011 1100
#     0000 1111 (a >> 1 연산 결과)
print("10 진법: ", (a >> 1), "\t|", "2 진법: ", bin(a >> 1) )


# 1 & (M>>N-1) : 마스크 연산. M의 오른쪽에서 N번째에 있는 비트의 값을 알고싶을때
# a = 0011 1100
#        1      (1 & (a >> 4)) 연산 결과
# b = 0000 1101
#        0      (1 & (b >> 4)) 연산 결과
print("(1 & (a >> 4)) 연산 결과: ", (1 & (a >>4)))
print("(1 & (b >> 4)) 연산 결과: ", (1 & (b >>4)))
